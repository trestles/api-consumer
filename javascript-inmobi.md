- efficient = the code is easily understood and well structured, fast to implement, fast to test, good library, ecosystem, questions get answered well on Stack Overflow; if a library or framework, the net win is a plus over writing raw code (sometimes hard to guage)

- efficient build a modern interface - sounds like a marketing person. From a dev pov, this is my experience and will interject what I think have been wins. I think they are:
- ES6 - a lot of ugly JS goes away (less concern about scope, arrow functions)
- reactivity
   - 1. a lot of event handlers and go away and code base decreases
- code tends to stay more local

- a brief history of my JS experience
   - JS -> -> jQuery ->  Dojo (briefly) -> jQuery again -> Emberjs / Angular (very briefly) / Knockout ->  jQuery + Handlebars (4 years) -> Vue.j s
   - While I've been a full-stack engineer, I have to had to write a LOT of admin interfaces. 
   - The key qualities are predictability / stability,  developer efficiency in regards to code (in Vue, code can be either local or shared, very little event handlers), developer efficiency for tooling (vue-devtools, testing, webpack, linting, babel!!!) and devloper efficiency in regards to library ecosystem. I want a Toyota Camry not a Ferrari. 
   - writing front-ends is extremely time-consuming
- three options as Angular (some version), React, Vue, jQuery + something, raw Javascript as ES6 (?)
- Also, I think there is more degrees of freedom than a DB choice which requires migration. I think all the frameworks here are suitable. 
- My gut choice would be either React or Vue. I had chosesn Vue because I felt it had a much lower barrier to entry. 

 
 
### Vue example 
- characterize: a mature, reactive framework with a lot of support (SO questions answered quickly, OReilly and Manning books). 
- A quick tour of features
  - Data Reactivity
    - reactivity
      - Virtual DOM - used by React and Ember 
         - uses .sync to update
         - advantage is that rather than writing 1000 updates to the DOM, you can batch your updates to the Virtual DOM and then do a single update
      - data - for it to be reactive, it should be declared here!
      - getter / setter conversion occurs during instance initalization
    - two-way data binding = v-model example
  - components
  - vuex for state management
  - vue-router

vue-cli 
yarn serve; will compile file into es5 compatible and auto-injected (this can vary across implementations)
webpack - very fast moving piece. Up to 4
package.json
vue inspect
access via $vm in the console







   - I want to think about Browser "issues" as little as possible
   - 90% of what is trying to be achieved is the same specifically render out UI's generated by JSON
   - setting handlers on DOM elements is inefficient for developer time. Every time I see jQuery, it's done slightly differently by each developer. 
   - a good example of a SPA is discourse (Rails / EmberJS app)

- Pragmatic Considerations and Assumptions
   - Development
   - writing the "wrong app" is the biggest problem in software development
      - as more interactivity / conditional rendering is introduced, accurate, well thought-out specs become more important
      - if you need to see it to determine if it's right, that's a problem
  - Business / Product 
      - People see the product
  - This is a big decision but React and Vue are similar
 
 
 
 
  {
"users": [
{
"id": 1,
"name": "Joe"
},
{
"id": 2,
"name": "Julie"
},
{
"id": 23,
"name": "Alex"
},
{
"id": 47,
"name": "Mary"
},
{
"id": 68,
"name": "Max"
}

],
"friends":[
  {"user_id":1, "friend_ids": [2,23,68]},
  {"user_id":2, "friend_ids": [1,23]},
  {"user_id":23, "friend_ids": [1,2,47]},
  {"user_id":68, "friend_ids": [1]}

]
}
 
 
 
- Vue source code  
 

- Modern Frameworks 
  - more efficient; code tends to be close to where you need it but can make common libraries
  - Reactivity
  - 
  - Vuex / VueRouter
  - Components - feature or a bug? 

- Moving to a modern Javascript framework
  - reactive nature (Rxjs for Reactjs; for Vue, it will be Observer)
     - UI is driven by underlying `data` and a set of filters and methods rather than forced re-renderings of the UI
     - much less event handling code 
     - console.log an object
  - introduces a more structured approach to code while maintaining a lean "happy path"
     - not dojo
  - SPA / vue-router
  - Global Data Store / vuex
     - Promises
  - strong ecosystem 
     - Vue webbrowser plugin
  - Webpack / Babel for moving to production (for Rails webpacker is 4.2 and above)
    - Babel allows for ES6 to be written and 
    - single file components and loaders
    - es6 vs es5 differences 
  - testing utils
  - linting utils 
    - AirBnB-style linter

- Some Vue-Specific Walkthroughs
  - some globals 
  - computed <----------> watched 
  - Virtual DOM
  - Shadow DOM
 

- Most Important Factors
  - Do we need a framework? 
  - If yes, what's the ramp-up time? 